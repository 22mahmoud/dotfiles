#!/bin/zsh

# ─────────────────────────────────────────────────────────────
# Symbols
# ─────────────────────────────────────────────────────────────
typeset -gA GITSTATUS_SYMBOLS=(
  [ahead]='⇡'
  [behind]='⇣'
  [push_ahead]='⇢'
  [push_behind]='⇠'
  [stash]='*'
  [staged]='+'
  [unstaged]='!'
  [untracked_files]='?'
  [merge_conflict]='~'
  [separator]=' '
)

# Cached separator for faster repeated use
typeset -g GIT_SEP="${GITSTATUS_SYMBOLS[separator]}"

# ─────────────────────────────────────────────────────────────
# Colors
# ─────────────────────────────────────────────────────────────
typeset -gA PROMPT_COLORS=(
  [path]='%F{blue}'
  [prompt_success]='%F{green}'
  [prompt_error]='%F{red}'
  [branch]='%F{magenta}'
  [clean]='%F{green}'
  [modified]='%F{yellow}'
  [untracked]='%F{blue}'
  [conflicted]='%F{red}'
  [stash]='%F{cyan}'
  [venv]='%F{cyan}'
)

typeset -g RESET='%f'

# ─────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────
typeset -gi GITSTATUS_MAX_BRANCH_LENGTH=32
typeset -g  _GIT_INSTANCE='MY'

# ─────────────────────────────────────────────────────────────
# Python/virtualenv prompt component
# ─────────────────────────────────────────────────────────────
# Disable the default virtualenv text so we can build our own
export VIRTUAL_ENV_DISABLE_PROMPT=1

# We use a global variable to store the string to avoid subshell lag
typeset -g VENV_PROMPT=""

venv_prompt_update() {
  if [[ -n $VIRTUAL_ENV ]]; then
    VENV_PROMPT=" ${PROMPT_COLORS[venv]}( ${VIRTUAL_ENV:t})${RESET}"
  else
    VENV_PROMPT=""
  fi
}

# ─────────────────────────────────────────────────────────────
# Branch formatting (truncate long names with ellipsis)
# ─────────────────────────────────────────────────────────────
_format_branch() {
  local raw="$1"
  local icon=" "

  if (( ${#raw} > GITSTATUS_MAX_BRANCH_LENGTH )); then
    local half=$(( (GITSTATUS_MAX_BRANCH_LENGTH - 1) / 2 ))
    printf '%s%s…%s' "$icon" "${raw[1,$half]}" "${raw[-$half,-1]}"
  else
    printf '%s%s' "$icon" "$raw"
  fi
}

# ─────────────────────────────────────────────────────────────
# Helper: append a colored indicator to $p if count > 0
#   Usage: _git_indicator COUNT COLOR_KEY SYMBOL_KEY
#   Accesses caller's local $p via dynamic scoping
# ─────────────────────────────────────────────────────────────
_git_indicator() {
  (( $1 )) && p+="$GIT_SEP${PROMPT_COLORS[$2]}${GITSTATUS_SYMBOLS[$3]}$1"
}

# ─────────────────────────────────────────────────────────────
# Gitstatus update hook
# ─────────────────────────────────────────────────────────────
gitstatus_prompt_update() {
  emulate -L zsh
  typeset -g GITSTATUS_PROMPT=''

  gitstatus_query "$_GIT_INSTANCE" || { GITSTATUS_PROMPT=''; return; }
  [[ $VCS_STATUS_RESULT == 'ok-sync' ]] || return

  local p=" on ${PROMPT_COLORS[branch]}"

  # Branch / tag / detached commit
  if [[ $VCS_STATUS_LOCAL_BRANCH ]]; then
    p+="$(_format_branch "$VCS_STATUS_LOCAL_BRANCH")"
  elif [[ $VCS_STATUS_TAG ]]; then
    p+="#$(_format_branch "$VCS_STATUS_TAG")"
  else
    p+=" @${VCS_STATUS_COMMIT[1,8]}"
  fi

  # Remote tracking status
  if (( VCS_STATUS_COMMITS_BEHIND || VCS_STATUS_COMMITS_AHEAD )); then
    p+="$GIT_SEP"
    _git_indicator $VCS_STATUS_COMMITS_BEHIND clean behind
    _git_indicator $VCS_STATUS_COMMITS_AHEAD  clean ahead
  fi

  # Push remote status
  if (( VCS_STATUS_PUSH_COMMITS_BEHIND || VCS_STATUS_PUSH_COMMITS_AHEAD )); then
    p+="$GIT_SEP"
    _git_indicator $VCS_STATUS_PUSH_COMMITS_BEHIND clean push_behind
    _git_indicator $VCS_STATUS_PUSH_COMMITS_AHEAD  clean push_ahead
  fi

  # Working tree status
  _git_indicator $VCS_STATUS_STASHES        stash      stash
  [[ $VCS_STATUS_ACTION ]] && p+="$GIT_SEP${PROMPT_COLORS[conflicted]}${VCS_STATUS_ACTION}"
  _git_indicator $VCS_STATUS_NUM_CONFLICTED conflicted merge_conflict
  _git_indicator $VCS_STATUS_NUM_STAGED     clean      staged
  _git_indicator $VCS_STATUS_NUM_UNSTAGED   modified   unstaged
  _git_indicator $VCS_STATUS_NUM_UNTRACKED  untracked  untracked_files

  GITSTATUS_PROMPT="${p}${RESET}"
}

# ─────────────────────────────────────────────────────────────
# Prompt setup
# ─────────────────────────────────────────────────────────────
prompt_setup() {
  if (( ${+PROMPT_SETUP_DONE} )); then
    return
  fi

  typeset -g PROMPT_SETUP_DONE=1

  setopt no_prompt_bang prompt_percent prompt_subst
  typeset -g prompt_newline=$'\n%{\r%}'

  # Start gitstatus daemon
  gitstatus_stop "$_GIT_INSTANCE" && gitstatus_start -s -1 -u -1 -c -1 -d -1 "$_GIT_INSTANCE"

  autoload -Uz add-zsh-hook
  add-zsh-hook precmd gitstatus_prompt_update
  add-zsh-hook precmd venv_prompt_update

  PROMPT=''
  PROMPT+='${prompt_newline}'
  PROMPT+='${PROMPT_COLORS[path]}%B%1~%b%f'
  PROMPT+='${VENV_PROMPT}'
  PROMPT+='$GITSTATUS_PROMPT'
  PROMPT+='${prompt_newline}%(?.${PROMPT_COLORS[prompt_success]}.${PROMPT_COLORS[prompt_error]})%B%b%f '
}

# Initialize once (guarded inside prompt_setup).
prompt_setup
