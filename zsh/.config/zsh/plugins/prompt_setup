#!/bin/zsh

# ─────────────────────────────────────────────────────────────
# Symbols
# ─────────────────────────────────────────────────────────────
typeset -gA GITSTATUS_SYMBOLS=(
  [ahead]='⇡'
  [behind]='⇣'
  [push_ahead]='⇢'
  [push_behind]='⇠'
  [stash]='*'
  [staged]='+'
  [unstaged]='!'
  [untracked_files]='?'
  [merge_conflict]='~'
  [separator]=' '
)

# Cached separator for faster repeated use
typeset -g GIT_SEP="${GITSTATUS_SYMBOLS[separator]}"

# ─────────────────────────────────────────────────────────────
# Colors
# ─────────────────────────────────────────────────────────────
typeset -gA PROMPT_COLORS=(
  [path]='%F{blue}'
  [prompt_success]='%F{green}'
  [prompt_error]='%F{red}'
  [branch]='%F{magenta}'
  [clean]='%F{green}'
  [modified]='%F{yellow}'
  [untracked]='%F{blue}'
  [conflicted]='%F{red}'
  [stash]='%F{cyan}'
  [venv]='%F{cyan}'
  [exec_time]='%F{yellow}'
  [jobs]='%F{cyan}'
  [ssh]='%F{cyan}'
  [readonly]='%F{red}'
)

typeset -g RESET='%f'

# ─────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────
typeset -gi GITSTATUS_MAX_BRANCH_LENGTH=32
typeset -g  _GIT_INSTANCE='MY'

# ─────────────────────────────────────────────────────────────
# Python/virtualenv prompt component
# ─────────────────────────────────────────────────────────────
# Disable the default virtualenv text so we can build our own
export VIRTUAL_ENV_DISABLE_PROMPT=1

# We use a global variable to store the string to avoid subshell lag
typeset -g VENV_PROMPT=""

venv_prompt_update() {
  if [[ -n $VIRTUAL_ENV ]]; then
    VENV_PROMPT=" ${PROMPT_COLORS[venv]}( ${VIRTUAL_ENV:t})${RESET}"
  else
    VENV_PROMPT=""
  fi
}

# ─────────────────────────────────────────────────────────────
# Execution time component
# ─────────────────────────────────────────────────────────────
zmodload zsh/datetime

typeset -g _prompt_cmd_start_time=""
typeset -g EXEC_TIME_PROMPT=""

_prompt_preexec_time() {
  _prompt_cmd_start_time=$EPOCHREALTIME
}

_prompt_precmd_time() {
  EXEC_TIME_PROMPT=""
  if [[ -n $_prompt_cmd_start_time ]]; then
    local -F elapsed=$(( EPOCHREALTIME - _prompt_cmd_start_time ))
    _prompt_cmd_start_time=""

    if (( elapsed >= 1.0 )); then
      local -i h=$(( elapsed / 3600 ))
      local -i m=$(( elapsed / 60 % 60 ))
      local -F s=$(( elapsed % 60 ))

      local formatted=""
      (( h > 0 )) && formatted+="${h}h "
      (( m > 0 )) && formatted+="${m}m "

      if (( h == 0 && m == 0 )); then
        formatted+=$(LC_NUMERIC=C printf "%.1fs" $s)
      else
        formatted+=$(LC_NUMERIC=C printf "%.0fs" $s)
      fi

      EXEC_TIME_PROMPT=" ${PROMPT_COLORS[exec_time]}󱎫 ${formatted}${RESET}"
    fi
  fi
}

# ─────────────────────────────────────────────────────────────
# Branch formatting (truncate long names with ellipsis)
# ─────────────────────────────────────────────────────────────
_format_branch() {
  local raw="$1"
  local icon=" "

  if (( ${#raw} > GITSTATUS_MAX_BRANCH_LENGTH )); then
    local half=$(( (GITSTATUS_MAX_BRANCH_LENGTH - 1) / 2 ))
    printf '%s%s…%s' "$icon" "${raw[1,$half]}" "${raw[-$half,-1]}"
  else
    printf '%s%s' "$icon" "$raw"
  fi
}

# ─────────────────────────────────────────────────────────────
# Helper: append a colored indicator to $p if count > 0
#   Usage: _git_indicator COUNT COLOR_KEY SYMBOL_KEY
#   Accesses caller's local $p via dynamic scoping
# ─────────────────────────────────────────────────────────────
_git_indicator() {
  (( $1 )) && p+="$GIT_SEP${PROMPT_COLORS[$2]}${GITSTATUS_SYMBOLS[$3]}$1"
}

# ─────────────────────────────────────────────────────────────
# Gitstatus update hook
# ─────────────────────────────────────────────────────────────
gitstatus_prompt_update() {
  emulate -L zsh
  typeset -g GITSTATUS_PROMPT=''

  gitstatus_query "$_GIT_INSTANCE" || { GITSTATUS_PROMPT=''; return; }
  [[ $VCS_STATUS_RESULT == 'ok-sync' ]] || return

  local p=" on ${PROMPT_COLORS[branch]}"

  # Branch / tag / detached commit
  if [[ $VCS_STATUS_LOCAL_BRANCH ]]; then
    p+="$(_format_branch "$VCS_STATUS_LOCAL_BRANCH")"
  elif [[ $VCS_STATUS_TAG ]]; then
    p+="#$(_format_branch "$VCS_STATUS_TAG")"
  else
    p+=" @${VCS_STATUS_COMMIT[1,8]}"
  fi

  # Remote tracking status
  if (( VCS_STATUS_COMMITS_BEHIND || VCS_STATUS_COMMITS_AHEAD )); then
    p+="$GIT_SEP"
    _git_indicator $VCS_STATUS_COMMITS_BEHIND clean behind
    _git_indicator $VCS_STATUS_COMMITS_AHEAD  clean ahead
  fi

  # Push remote status
  if (( VCS_STATUS_PUSH_COMMITS_BEHIND || VCS_STATUS_PUSH_COMMITS_AHEAD )); then
    p+="$GIT_SEP"
    _git_indicator $VCS_STATUS_PUSH_COMMITS_BEHIND clean push_behind
    _git_indicator $VCS_STATUS_PUSH_COMMITS_AHEAD  clean push_ahead
  fi

  # Working tree status
  _git_indicator $VCS_STATUS_STASHES        stash      stash
  [[ $VCS_STATUS_ACTION ]] && p+="$GIT_SEP${PROMPT_COLORS[conflicted]}${VCS_STATUS_ACTION}"
  _git_indicator $VCS_STATUS_NUM_CONFLICTED conflicted merge_conflict
  _git_indicator $VCS_STATUS_NUM_STAGED     clean      staged
  _git_indicator $VCS_STATUS_NUM_UNSTAGED   modified   unstaged
  _git_indicator $VCS_STATUS_NUM_UNTRACKED  untracked  untracked_files

  GITSTATUS_PROMPT="${p}${RESET}"
}

# ─────────────────────────────────────────────────────────────
# Read-only indicator hook
# ─────────────────────────────────────────────────────────────
typeset -g DIR_READONLY_PROMPT=""

_prompt_precmd_readonly() {
  if [[ ! -w $PWD ]]; then
    DIR_READONLY_PROMPT=" ${PROMPT_COLORS[readonly]}${RESET}"
  else
    DIR_READONLY_PROMPT=""
  fi
}

# ─────────────────────────────────────────────────────────────
# Prompt setup
# ─────────────────────────────────────────────────────────────
prompt_setup() {
  if (( ${+PROMPT_SETUP_DONE} )); then
    return
  fi

  typeset -g PROMPT_SETUP_DONE=1

  setopt no_prompt_bang prompt_percent prompt_subst
  typeset -g prompt_newline=$'\n%{\r%}'

  # SSH context
  typeset -g SSH_PROMPT=''
  if [[ -n $SSH_CLIENT || -n $SSH_TTY ]]; then
    SSH_PROMPT="${PROMPT_COLORS[ssh]}%n@%m${RESET} "
  fi

  # Start gitstatus daemon
  gitstatus_stop "$_GIT_INSTANCE" && gitstatus_start -s -1 -u -1 -c -1 -d -1 "$_GIT_INSTANCE"

  autoload -Uz add-zsh-hook
  add-zsh-hook precmd gitstatus_prompt_update
  add-zsh-hook precmd venv_prompt_update
  add-zsh-hook preexec _prompt_preexec_time
  add-zsh-hook precmd _prompt_precmd_time
  add-zsh-hook precmd _prompt_precmd_readonly

  PROMPT=''
  PROMPT+='${prompt_newline}'
  PROMPT+='${SSH_PROMPT}'
  PROMPT+='${PROMPT_COLORS[path]}%B%1~%b${RESET}'
  PROMPT+='${DIR_READONLY_PROMPT}'
  PROMPT+='${VENV_PROMPT}'
  PROMPT+='$GITSTATUS_PROMPT'
  PROMPT+='${prompt_newline}%(?.${PROMPT_COLORS[prompt_success]}.${PROMPT_COLORS[prompt_error]})%B%(#.#.)%b${RESET} '

  RPROMPT=''
  RPROMPT+='${EXEC_TIME_PROMPT}'
  RPROMPT+='%(1j. ${PROMPT_COLORS[jobs]} %j${RESET}.)'
}

# Initialize once (guarded inside prompt_setup).
prompt_setup
